> https://juejin.cn/post/7244720558772256826
>
> https://juejin.cn/post/7097906848505806885
>
> https://juejin.cn/post/7249163421694083129
>
> https://juejin.cn/post/7104088592426729480
>
> https://juejin.cn/post/7083414641610588168
>
> https://juejin.cn/post/7066430627221864485
>
> https://juejin.cn/post/7108003663582494733
>
> https://juejin.cn/post/7220784048204939323
>
> https://juejin.cn/post/7248896036709630009
>
> https://juejin.cn/post/7179122320660201532
>
> https://juejin.cn/post/7232114747347484709
>
> https://segmentfault.com/a/1190000022640407



monorepo eslint问题 

https://github.com/typescript-eslint/typescript-eslint/issues/1192



> 大家好，我是josiefang，本次前端sig我分享的主题是：前端包管理工具的演进和Monorepo初探。
>
> 本次分享将主要从以下两部分进行展开。
>
> 第一部分是前端包管理器，将主要介绍前端包管理器工具，在迭代演进的过程中，提出的一些创新性特性，以及其遇到困难是如何解决的
>
> 第二部分是monorepo的相关内容，相信大家对它也不陌生。我将主要介绍它的诞生背景，为了解决哪些问题，以及几种monorepo解决方案分别是如何实现的。



# 1⃣️前端包管理器

首先是前端包管理器部分



## 概述

包管理器是一个通用的概念，很多语言中都有包管理器，它是一个可以让开发者便捷地获取代码和分发代码的工具

在早期，前端还没有工程化的概念，当我们想要复用开源成熟的第三方库或者框架的时候，我们只能去它的官网下载源码，再手动拷贝到我们的项目中，或者通过第三方提供的cdn进行引入

当第三方库迭代进行版本更新的时候，我们也得重新去手动下载，手动进行版本更新，也就是说依赖管理和版本管理都需要人工手动处理。

随着node的出现，前端开发也逐渐进入了工程化的阶段，

我们知道，一个工具的出现，一定是为了解决某些问题的，前端包管理器作为前端工具链中的一环，它解决了什么问题呢

其中最重要的就是，npm提供了一个代码仓库，根据其规范，开发者们将自己的代码进行上传，这样别人也可以快捷地获取这些公共的第三方库，大大便利了自己的开发工作。

其次是如前面所说的，原先在使用第三方库的时候需要手动下载和引入，手动进行版本和依赖的管理，那么npm提供了一些便捷的脚本指令来将繁琐的手动操作进行自动化，并且支持自动化的依赖管理和版本管理。



## node_modules

> https://juejin.cn/post/7166084189995925517?searchId=20230811001956AF446174B670D6485060#heading-14
>
> https://juejin.cn/post/7179466977239367735

那么npm 作为前端领域最早的包管理工具，它的早期版本的工作模式和现在还是有很大的区别的，其中最典型的就是 node_modules 的目录管理

比如说一个Application，它直接依赖了A和C，其中A和C又分别依赖了B

**在npm的v2版本及之前**，node_modules目录结构都是如左边图所示，层层嵌套的

这样设计的优点是符合直觉，依赖包的安装和目录结构都十分清晰且可预测

但是却带来了一些很严重的问题

1. 首先是依赖包的重复安装：B被A依赖，同时也被C依赖，在这样的组织结构下，B被安装了2次，造成了冗余安装，导致node_modules目录体积很大
2. 多个包之间难免会有公共的依赖，这样嵌套的话，同样的依赖会复制很多次，会占据比较大的磁盘空间。
3. 其次是当项目依赖的包，嵌套层级很深的时候，会导致操作系统所需要处理的路径过长，这样可能会存在一些问题

**因此，在v3版本中**，npm的设计进行了优化，将node_modules目录结构进行扁平化，也就是hoist机制

npm在处理A依赖B时，将B提升到顶层也就是Application的node_modules中，然后在处理C包，由于B已经在它的上层了，因此不需要再重复安装了

这样，扁平化的结构可以避免前面提到的这两个问题

如果再考虑到版本的话

虽然A和C都依赖了B，但是如果他们依赖的B版本不同的话该怎么办呢

不同版本无法共享。

比如说A依赖了B的v1版本，这样在处理A的时候，会将Bv1进行提升，在处理C时，由于顶层已经存在Bv1了，所以Bv2无法提升，只能放在C下

因此可以看出，npm的v3版本的hoist机制只是在一定程度上解决了Node_modules嵌套结构存在的问题



## npm v3 hoist 机制存在的问题

hoist机制并不能做到完全的扁平化，而且还出现了新的问题

1. 第一个是幽灵依赖
   1. 
   2. 在顶层node_modules下的依赖包，开发者可以直接使用，但依赖包没定义在 package.json 中，这样的依赖包被称为 幽灵依赖
   3. 比如在刚刚的例子中，Bv1版本被提升到顶层了，那么虽然它没有被Application直接依赖，但是根据node的依赖查找方式，我们还是可以导入并使用它
   4. 但是由于这个使用并不被我们感知，后期如果A的更新导致其对B的引用也有了较大的变动时，那么Application中对B的调用就可能会出现问题
2. 第二个是双胞胎陌生人
   1. 比如这个例子中，虽然C和D中都依赖了Bv2，但是它们却被安装了两遍，使得包体积变大
3. 第三个是依赖不幂等，依赖安装顺序决定了哪个版本提升到顶层
   1. 还是刚刚这个例子
   2. 开发过程中手动安装的话，如果先安装A，那么Bv1会被提升，如果先安装C，那么Bv2会被提升
   3. 如果是用npm install进行安装的话，安装的先后顺序则由依赖包的字母顺序进行排序
   4. 因此并不能保证依赖安装多人开发时，node_modules 目录结构是一致的



## 安全、提速

那么针对依赖不幂等造成的安全问题，包管理器的解决方案是这样发展的

首先，在npm的v3版本中，是有相应的解决方案的，也就是npm-shrinkwrap.json文件

不过它需要手动执行指令去生成，此后版本依赖变更后，也无法自动更新该文件，仍需要手动执行指令去更新，因此使用起来很繁琐

那么在yarn诞生后，它通过yarn.lock文件记录了包的版本和依赖关系

在npm的v5版本中，也借鉴了这个思路，自动生成和更新package-lock.json锁文件

自动生成与更新的锁文件精确锁定了依赖版本，保证了每次安装依赖版本都一样，避免了依赖包安装时的版本不一致问题。



其次，随着包管理器的发展，依赖包的安装速度也大大提高。

在npm的v1和v2版本时，依赖包时串行安装的，而且不存在离线缓存

yarn和npm此后也逐渐完善了并行安装和离线缓存的功能。



## npm install

npm install 指令经历了如下过程：

package.json是一个前端工程化项目的描述文件，其中有非常多的属性，我这里简单梳理总结了一下一些主要属性的

其中必须填写的只有两个：name 和 version ，这两个属性组成一个 npm 模块的唯一标识。

## yarn

yarn包管理器，是Facebook工程师不满于npm所存在的一些问题，在npm v3基础上进行创新，开发的一个新的管理器



## pnpm

> https://juejin.cn/post/6969450118839795749#comment

虽然yarn和npm相互借鉴共同进步，但是他们的node_modules扁平化管理方式还是差不多的，并没有解决幽灵依赖和包的重复安装的问题

pnpm在依赖包管理上完全摒弃了npm的底层逻辑，巧妙地通过symbol link和hard link，做出了自己的创新。



## 硬链接和软链接

## 依赖管理和版本管理机制





npm 作为前端领域最早的包管理工具，其早期版本（v1/v2）的工作模式和现在还是有很大的区别，其中最典型的就是 node_modules 的目录管理。





# 2⃣️monorepo

> 【带你了解更全面的 Monorepo - 优劣、踩坑、选型 - 掘金】：https://medium.com/@magenta2127/monorepo-vs-multi-repo-vs-monolith-7c4a5f476009
>
> 【monorepo.tools】https://monorepo.tools/
>
> https://juejin.cn/post/7237145375311839289?searchId=20230719192929F0195F8CADF5827BB693#heading-9
>
> 神光大佬yyds：https://juejin.cn/post/7220681627977318458?searchId=202308240048555961E72CCF27747BA801#heading-0



## 背景

monorepo是一种单仓多包的项目代码管理方式，指在单个仓库中管理多个项目

主流的开源包基本都是用 monorepo 形式进行管理的，为什么用 monorepo 也很容易理解

比如 babel 有这样的一系列的包，如果每个包单独一个仓库，那就有十多个 git 仓库，这些 git 仓库每个都要单独来一套工程化配置，也就是重复十多次

工程化部分重复还不是最大的问题，最大的问题还是这三个：

1. 如果一个项目依赖了一个本地还在开发的包，我们会通过 npm link 的方式把这个正在开发的包 link 到全局，然后再 link 到那个项目的 node_modules 下。如果只是一个包的话，npm link 还是方便的。但现在有十几个包了，这样来十多次就很麻烦了。
2. 需要在每个包里执行命令，现在也是要分别进入到不同的目录下来执行十多次。最关键的是有一些包需要根据依赖关系来确定执行命令的先后顺序。
3. 版本更新的时候，要手动更新所有包的版本，如果这个包更新了，那么依赖它的包也要发个新版本才行。

因为这三个问题：npm link 比较麻烦、执行命令比较麻烦、版本更新比较麻烦，所以就有了对 monorepo 的项目组织形式和工具的需求。



## 方案1

monorepo的实现方案有以下两类

第一类是轻量化的monorepo 方案，其中早期的有lerna，然后包管理器陆续都支持了workspace功能之后，包管理器结合workspace就能实现轻量级的monorepo

接下来，针对前面提到的npm link 比较麻烦、执行命令比较麻烦、版本更新比较麻烦这三个问题，我们来看下lerna和包管理器结合workspace两种方案是如何解决的



## Learn



## workspace

workspaces（工作区）是一个通用术语，它支持了monorepo单仓多包管理。

它支持了一组功能，这组功能使得在本地同时开发多个包时，进行本地包调用时的工作流程更加简化。

>  作为 npm install 的一部分自动执行链接过程，并避免手动使用 npm link 来添加对应符号链接到当前 node_modules 文件夹中的包的引用。

npm、yarn、pnpm都提供了对workspaces的支持，在使用上会有些微的不同

其中npm和yarn基本类似，就是一些指令有一些不同，这里以npm为例

通过workspace定义一个monorepo项目，有两种方式

1. 手动在monorepo项目的package.json中添加workspaces字段
   1. 如图所示，这里的路径指向指的是package.json所在文件夹文件夹名
   2. 然后根据定义的路径名创建对应的包
   3. 再执行npm install
   4. workspace-a项目被链接到项目的node_modules中
2. 第二种是，在确保根目录的package.json存在时，通过指令
   1. npm init -w ./packages/b -y
   2. 这样会自动创建指定路径的包，并且将这个包添加到根目录的package.json的workspaces字段中



## pnpm+workspace

与npm、yarn不同，pnpm的workspaces的配置都放在pnpm-workspace.yaml文件里，一个 workspace 的根目录下必须有 pnpm-workspace.yaml 文件

pnpm-workspace.yaml 定义了 工作空间 的根目录，并能够使您从工作空间中包含 / 排除目录 。 默认情况下，包含所有子目录。



## 方案2

其次是构建型的方案，此类工具主要是解决大仓库 Monorepo 构建效率低的问题。

项目代码仓库越来越庞大，工作流（int、构建、单元测试、集成测试）也会越来越慢；这类工具，是专门针对这样的场景进行极致的性能优化。适用于包非常多、代码体积非常大的 Monorepo 项目

## Turborepo









> 【前端】快速完成技术分享PPT心得
>
> 其他方向应该也适用吧
>
> 1. 定主题
>    - 可以是你想学习或者感兴趣的模块，正好可以趁机学透它
> 2. 万事开头难，我认为PPT的目录或者说框架是最难写的，可能会卡壳很久，怎么办呢？
>    1. 拿着主题去博客搜，疯狂找，找到为止
>    2. 找到一个你觉得写的好的文章，它的目录结构也很不错
>    3. 抄就完了，把文章转化成PPT的组织形式，借鉴它的架子，可以结合你的理解进行修改
> 3. 疯狂link相关文章，完善你的PPT内容。
